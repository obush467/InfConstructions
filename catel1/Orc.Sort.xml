<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Orc.Sort</name>
    </assembly>
    <members>
        <member name="T:Orc.Sort.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Orc.Sort.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Orc.Sort.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:Orc.Sort.IEnumerableExtensions.EnumerateFrom``1(System.Collections.Generic.IEnumerable{``0},``0,System.Boolean)">
            <summary>
            Enumerate through a collection starting from a specified item.
            The collection must have unique values.
            Example:
             {"A", "B", "C", "D", "E"}.EnumerateFrom("B") == {"B", "C", "D", "E", "A"}
            </summary>
            <typeparam name="T">Must be equatable</typeparam>
            <param name="items">The collection to enumerate over</param>
            <param name="startValue">The start value to start enumerating from</param>
            <param name="isCyclic">Specify whether to stop once the end of the collection is reached or wrap around and enumerate all the items in the collection</param>
            <returns></returns>
        </member>
        <member name="M:Orc.Sort.IEnumerableExtensions.MergeSorted``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>
            Takes a collection of sorted items and merges these collections together in order to return one sorted collection.
            </summary>
            <typeparam name="T"> Must be comparable. </typeparam>
            <param name="sortedEnumerables"></param>
            <param name="distinct"></param>
            <returns></returns>
        </member>
        <member name="M:Orc.Sort.IEnumerableExtensions.MergeSorted``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>
            Takes a collection of sorted items and merges these collections together in order to return one sorted collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sortedEnumerables"></param>
            <param name="itemComparer"></param>
            <param name="distinct"></param>
            <returns></returns>
        </member>
        <member name="M:Orc.Sort.IEnumerableExtensions.MergeSortedMany``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IComparer{``0})">
            <summary>
            Takes a collection of sorted items and merges these collections together in order to return one sorted collection.
            
            This version is optimized for a high number of collections to merge (100+).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sortedEnumerables"></param>
            <param name="itemComparer"></param>
            <returns></returns>
        </member>
        <member name="T:Orc.Sort.ISorter">
            <summary>
            Summary description for ISorter.
            </summary>
        </member>
        <member name="T:Orc.Sort.ISwap">
            <summary>
            Object swapper interface
            </summary>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.BubbleSorter`1">
            <summary>
            Bubble sort sequential algorithm
            </summary>
            <remarks>
            <para>
            Bubble sort is a sequential sorting algorithm that runs in
            <em>O(n^2)</em>, where <em>n</em> is the number of elements in the 
            list.
            </para>
            <para>
            Source: <a href="http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html">
            http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html</a>
            </para>
            </remarks>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.ComparableComparer`1">
            <summary>
            Default <see cref="T:System.IComparable"/> object comparer.
            </summary>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.DefaultSwap`1">
            <summary>
            Default swap class
            </summary>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.FastQuickSorter`1">
            <summary>
            A fast quick sort demonstration algorithm
            </summary>
            <remarks>
            <para>
            Author James Gosling, Kevin A. Smith, 
            </para>
            <para>
            Source: http://www.cs.ubc.ca/spider/harrison/Java/FastQSortAlgorithm.java.html
            </para>
            <para>
            Ported to C# by Jonathand de Halleux
            </para>
            </remarks>
        </member>
        <member name="M:Orc.Sort.NSort.Generic.FastQuickSorter`1.QuickSort(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            This is a generic version of C.A.R Hoare's Quick Sort 
            algorithm.  This will handle arrays that are already
            sorted, and arrays with duplicate keys.
            </summary>
            <remarks>
            If you think of a one dimensional array as going from
            the lowest index on the left to the highest index on the right
            then the parameters to this function are lowest index or
            left and highest index or right.  The first time you call
            this function it will be with the parameters 0, a.length - 1.
            </remarks>
            <param name="list">list to sort</param>
            <param name="l">left boundary of array partition</param>
            <param name="r">right boundary of array partition</param>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.OddEvenTransportSorter`1">
            <summary>
            Odd-Even Transport sort parralel algorithm
            </summary>
            <remarks>
            <para>
            Source: <a href="http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html">
            http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html</a>
            </para>
            </remarks>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.QuickSorter`1">
            <summary>
            http://www.codeproject.com/csharp/csquicksort.asp
            </summary>
        </member>
        <member name="M:Orc.Sort.NSort.Generic.QuickSorter`1.Sort(System.Collections.Generic.IList{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="array">The array to sort.</param>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.ShearSorter`1">
            <summary>
            Shear sort parralel algorithm
            </summary>
            <remarks>
            <para>
            Source: <a href="http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html">
            http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html</a>
            </para>
            </remarks>
        </member>
        <member name="T:Orc.Sort.NSort.Generic.SwapSorter`1">
            <summary>
            Abstract base class for Swap sort algorithms.
            </summary>
            <remarks>
            <para>
            This class serves as a base class for swap based sort algorithms.
            </para>
            </remarks>
        </member>
        <member name="P:Orc.Sort.NSort.Generic.SwapSorter`1.Comparer">
            <summary>
            Gets or sets the <see cref="T:System.Collections.IComparer"/> object
            </summary>
            <value>
            Comparer object
            </value>
            <exception cref="T:System.ArgumentNullException">
            Set property, the value is a null reference
            </exception>
        </member>
        <member name="P:Orc.Sort.NSort.Generic.SwapSorter`1.Swapper">
            <summary>
            Gets or set the swapper object
            </summary>
            <value>
            The <see cref="T:Orc.Sort.ISwap"/> swapper.
            </value>
            <exception cref="T:System.ArgumentNullException">Swapper is a null reference</exception>
        </member>
        <member name="T:Orc.Sort.NSort.BubbleSorter">
            <summary>
            Bubble sort sequential algorithm
            </summary>
            <remarks>
            <para>
            Bubble sort is a sequential sorting algorithm that runs in
            <em>O(n^2)</em>, where <em>n</em> is the number of elements in the 
            list.
            </para>
            <para>
            Source: <a href="http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html">
            http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html</a>
            </para>
            </remarks>
        </member>
        <member name="T:Orc.Sort.NSort.ComparableComparer">
            <summary>
            Default <see cref="T:System.IComparable"/> object comparer.
            </summary>
        </member>
        <member name="T:Orc.Sort.NSort.DefaultSwap">
            <summary>
            Default swap class
            </summary>
        </member>
        <member name="T:Orc.Sort.NSort.FastQuickSorter">
            <summary>
            A fast quick sort demonstration algorithm
            </summary>
            <remarks>
            <para>
            Author James Gosling, Kevin A. Smith, 
            </para>
            <para>
            Source: http://www.cs.ubc.ca/spider/harrison/Java/FastQSortAlgorithm.java.html
            </para>
            <para>
            Ported to C# by Jonathand de Halleux
            </para>
            </remarks>
        </member>
        <member name="M:Orc.Sort.NSort.FastQuickSorter.QuickSort(System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            This is a generic version of C.A.R Hoare's Quick Sort 
            algorithm.  This will handle arrays that are already
            sorted, and arrays with duplicate keys.
            </summary>
            <remarks>
            If you think of a one dimensional array as going from
            the lowest index on the left to the highest index on the right
            then the parameters to this function are lowest index or
            left and highest index or right.  The first time you call
            this function it will be with the parameters 0, a.length - 1.
            </remarks>
            <param name="list">list to sort</param>
            <param name="l">left boundary of array partition</param>
            <param name="r">right boundary of array partition</param>
        </member>
        <member name="T:Orc.Sort.NSort.OddEvenTransportSorter">
            <summary>
            Odd-Even Transport sort parralel algorithm
            </summary>
            <remarks>
            <para>
            Source: <a href="http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html">
            http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html</a>
            </para>
            </remarks>
        </member>
        <member name="T:Orc.Sort.NSort.QuickSorter">
            <summary>
            http://www.codeproject.com/csharp/csquicksort.asp
            </summary>
        </member>
        <member name="M:Orc.Sort.NSort.QuickSorter.Sort(System.Collections.IList)">
            <summary>
            Sorts the array.
            </summary>
            <param name="array">The array to sort.</param>
        </member>
        <member name="T:Orc.Sort.NSort.ShearSorter">
            <summary>
            Shear sort parralel algorithm
            </summary>
            <remarks>
            <para>
            Source: <a href="http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html">
            http://www.cs.rit.edu/~atk/Java/Sorting/sorting.html</a>
            </para>
            </remarks>
        </member>
        <member name="T:Orc.Sort.NSort.SwapSorter">
            <summary>
            Abstract base class for Swap sort algorithms.
            </summary>
            <remarks>
            <para>
            This class serves as a base class for swap based sort algorithms.
            </para>
            </remarks>
        </member>
        <member name="P:Orc.Sort.NSort.SwapSorter.Comparer">
            <summary>
            Gets or sets the <see cref="T:System.Collections.IComparer"/> object
            </summary>
            <value>
            Comparer object
            </value>
            <exception cref="T:System.ArgumentNullException">
            Set property, the value is a null reference
            </exception>
        </member>
        <member name="P:Orc.Sort.NSort.SwapSorter.Swapper">
            <summary>
            Gets or set the swapper object
            </summary>
            <value>
            The <see cref="T:Orc.Sort.ISwap"/> swapper.
            </value>
            <exception cref="T:System.ArgumentNullException">Swapper is a null reference</exception>
        </member>
        <member name="T:Orc.Sort.TemplateSort.TemplateSort">
            <summary>
            The template sort.
            </summary>
        </member>
        <member name="M:Orc.Sort.TemplateSort.TemplateSort.SortAccordingTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Sorts the elements of a sequence based on the order of the items in the specified template collection, using the
                specified System.Collections.Generic.IEqualityComparer&lt;T&gt;.
            </summary>
            <example>
                collection = [A, B, C, B, A, C, D, D]
                template = [B, A, D, C]
                collection.SortAccordingTo(template) = [B, B, A, A, D, D, C, C]
            </example>
            <typeparam name="T">
                The type of the collection to be sorted.
            </typeparam>
            <param name="sourceCollection">
                The sequence to be sorted.
            </param>
            <param name="templateCollection">
                A template collection that specifies the order in which the sequence will be sorted.
                May not contain duplicates.
            </param>
            <param name="includeNoMatches">
                Indicates whether the items in the source collection that do not match any items in the template collection should be appended to the result or not.
            </param>
            <param name="comparer">
                A System.Collections.Generic.IEqualityComparer&lt;T&gt; implementation to use when comparing the
                elements in the template collection, or null to use the default one.
            </param>
            <returns>
                Returns a list containing the sorted items.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                Thrown when either sourceCollection, keySelector or templateCollection is null.
            </exception>
            <exception cref="T:System.ArgumentException">
                Thrown when the template collection contains duplicates.
            </exception>
        </member>
        <member name="M:Orc.Sort.TemplateSort.TemplateSort.SortAccordingTo``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1},System.Boolean,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Sorts the elements of a sequence based on the order of the items in the specified template collection, using the
                specified System.Collections.Generic.IEqualityComparer&lt;T&gt;.
            </summary>
            <example>
                collection = [A, B, C, B, A, C, D, D]
                template = [B, A, D, C]
                collection.SortAccordingTo(template) = [B, B, A, A, D, D, C, C]
            </example>
            <typeparam name="TSource">
                The type of the items to be sorted.
            </typeparam>
            <typeparam name="TKey">
                The type of the items in the template collection.
            </typeparam>
            <param name="sourceCollection">
                The sequence to be sorted.
            </param>
            <param name="templateCollection">
                A template collection that specifies the order in which the sequence will be sorted.
                May not contain duplicates.
            </param>
            <param name="keySelector">
                A function to extract a key from an element.
            </param>
            <param name="includeNoMatches">
                Indicates whether the items in the source collection that do not match any items in the template collection should be appended to the result or not.
            </param>
            <param name="comparer">
                A System.Collections.Generic.IEqualityComparer&lt;T&gt; implementation to use when comparing the
                elements in the template collection, or null to use the default one.
            </param>
            <returns>
                Returns a list containing the sorted items.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                Thrown when either sourceCollection, keySelector or templateCollection is null.
            </exception>
            <exception cref="T:System.ArgumentException">
                Thrown when the template collection contains duplicates.
            </exception>
        </member>
        <member name="T:Orc.Sort.TopologicalSort.PriorityTopologicalSort`1">
            <summary>
            Uses a standard topological sort but gives priority to an item if it is encountered first.
            </summary>
            <typeparam name="T">
            </typeparam>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.PriorityTopologicalSort`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Orc.Sort.TopologicalSort.PriorityTopologicalSort`1"/> class.
            </summary>
        </member>
        <member name="T:Orc.Sort.TopologicalSort.TopologicalSort`1">
            <summary>
            Standard topological sort.
            Should be faster than the PriorityTopologicalSort
            </summary>
            <typeparam name="T">
            </typeparam>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.edgesFrom">
            <summary>
            The edges from each node.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.edgesInto">
            <summary>
            The edges into each node.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.firstConflict">
            <summary>
            First conflicting sequence.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.nodesDict">
            <summary>
            The nodes dictionary. Maps nodes to IDs.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.nodesList">
            <summary>
            The nodes list. Maps IDs to their nodes.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.nodesSort">
            <summary>
            List of nodes in the sort order.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.transFrom">
            <summary>
            The edges from each node - transitive closure.
            </summary>
        </member>
        <member name="F:Orc.Sort.TopologicalSort.TopologicalSort`1.transInto">
            <summary>
            The edges into each node - transitive closure.
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.#ctor(System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Orc.Sort.TopologicalSort.PriorityTopologicalSort`1"/> class.
            </summary>
        </member>
        <member name="P:Orc.Sort.TopologicalSort.TopologicalSort`1.Sequences">
            <summary>
            Gets the sequences.
            The order of items within each sequence is important and will preserved in the final merged sequence.
            If the sorter uses priority, additionally the appearance order of each item will be used if possible.
            </summary>
        </member>
        <member name="P:Orc.Sort.TopologicalSort.TopologicalSort`1.UsesPriority">
            <summary>
            Gets the value indicating whether priority will be used or not.
            </summary>
        </member>
        <member name="P:Orc.Sort.TopologicalSort.TopologicalSort`1.UsesTracking">
            <summary>
            Gets the value indicating whether tracking will be used or not.
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            The add.
            </summary>
            <param name="sequence">
            The new group.
            </param>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            The add range.
            </summary>
            <param name="newSequences">
            The new groups.
            </param>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.CanSort(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            The can sort.
            </summary>
            <param name="sequence">
            The sub list.
            </param>
            <returns>
            The <see cref="T:System.Boolean"/>.
            </returns>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.Sort">
            <summary>
            The sort.
            </summary>
            <returns>
            The <see cref="T:System.Collections.Generic.List`1"/>.
            </returns>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.GetConflicts">
            <summary>
            Returns the first pair of sequences that are in conflict with each other.
            </summary>
            <returns>The <see cref="T:System.Collections.Generic.List`1" />.</returns>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.NodeKey(`0)">
            <summary>
            The node key.
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.NodeKeySafe(`0,System.Collections.Generic.Dictionary{`0,System.Int32})">
            <summary>
            The node key - safe.
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.GetPrecedents(`0,System.Boolean,System.Boolean)">
            <summary>
            Returns the list of all nodes that the given node depends on. (Nodes that must come before the given node.)
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.GetDependents(`0,System.Boolean,System.Boolean)">
            <summary>
            Returns the list of all nodes that depend on the given node. (Nodes that must come after the given node.)
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.GetRelated(System.Int32,System.Boolean,System.Boolean,System.Collections.Generic.List{System.Collections.Generic.HashSet{System.Int32}},System.Collections.Generic.List{System.Collections.Generic.HashSet{System.Int32}},System.Boolean)">
            <summary>
            Returns the list of all nodes that are related to the given node.
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.EdgesWalk(System.Int32,System.Collections.Generic.List{System.Collections.Generic.HashSet{System.Int32}})">
            <summary>
            Walks the edges of the given node recursively, and returns a set of visited nodes.
            </summary>
        </member>
        <member name="M:Orc.Sort.TopologicalSort.TopologicalSort`1.EdgesWalkLazy(System.Int32,System.Collections.Generic.List{System.Collections.Generic.HashSet{System.Int32}})">
            <summary>
            Walks the edges of the given node recursively, and yields each visited node.
            </summary>
        </member>
        <member name="T:MethodTimeLogger">
            <summary>
            Note: do not rename this class or put it inside a namespace.
            </summary>
        </member>
        <member name="T:ModuleInitializer">
            <summary>
            Used by the ModuleInit. All code inside the Initialize method is ran as soon as the assembly is loaded.
            </summary>
        </member>
        <member name="M:ModuleInitializer.Initialize">
            <summary>
            Initializes the module.
            </summary>
        </member>
        <member name="T:System.Linq.TimSortExtender">
            <summary>
            <![CDATA[T[], List<T> and IList<T>]]> extender providing TimSort extension methods.
            </summary>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryNativeTimSort``1(``0[])">
            <summary>Tries to use native sorting on given array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <returns><c>true</c> if sorted using native types, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryNativeTimSort``1(``0[],System.Int32,System.Int32)">
            <summary>Tries to use native sorting on given array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="lo">The low limit.</param>
            <param name="hi">The high limit.</param>
            <returns><c>true</c> if sorted using native types, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[])">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="T:System.Linq.TimSortExtender.SorterProxy">
            <summary>Proxy object to resolve sorter dynamically.</summary>
        </member>
        <member name="F:System.Linq.TimSortExtender.SorterProxy.SortAll">
            <summary>The sort all proxy.</summary>
        </member>
        <member name="F:System.Linq.TimSortExtender.SorterProxy.SortRange">
            <summary>The sort range proxy.</summary>
        </member>
        <member name="M:System.Linq.TimSortExtender.IsIComparable``1">
            <summary>Determines whether type implements IComparable.</summary>
            <typeparam name="T">Any type.</typeparam>
            <returns><c>true</c> if  implements IComparable; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.GetComparableSorterProxy``2(System.Type)">
            <summary>Gets the sorter proxy for IComparable.</summary>
            <typeparam name="TContainer">The type of the container.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="sorterType">Type of the sorter.</param>
            <returns>Sorter proxy.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(``0[])">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="array">The array.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(``0[],System.Int32,System.Int32)">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="array">The array.</param>
            <param name="lo">The lower bound.</param>
            <param name="hi">The upper bound.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.List{``0})">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <param name="lo">The lower bound.</param>
            <param name="hi">The upper bound.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.IList{``0})">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <param name="lo">The lower bound.</param>
            <param name="hi">The upper bound.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="F:System.Linq.TimSortExtender.ItemMemberMap">
            <summary>The map of '_items' member in <see cref="T:System.Collections.Generic.List`1"/></summary>
        </member>
        <member name="M:System.Linq.TimSortExtender.GetInternalMember``1(System.Collections.Generic.List{``0})">
            <summary>Tries to get '_items' member from <see cref="T:System.Collections.Generic.List`1" />.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns>Array of items (if available)</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.GetInternalMember``1(System.Collections.Generic.IList{``0})">
            <summary>Tries to cast <see cref="T:System.Collections.Generic.IList`1" /> to <see cref="T:System.Collections.Generic.List`1" />.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns><see cref="T:System.Collections.Generic.List`1"/> if possible.</returns>
        </member>
        <member name="T:TimSort.ByteArrayTimSort">
            <summary>TimSort implementation for ByteArray.</summary>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.#ctor(System.Byte[])">
            <summary>
            Prevents a default instance of the ByteArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.Sort(System.Byte[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.Sort(System.Byte[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.BinarySort(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.CountRunAndMakeAscending(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.GallopLeft(System.Byte,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.GallopRight(System.Byte,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.SByteArrayTimSort">
            <summary>TimSort implementation for SByteArray.</summary>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.#ctor(System.SByte[])">
            <summary>
            Prevents a default instance of the SByteArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.Sort(System.SByte[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.Sort(System.SByte[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.BinarySort(System.SByte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.CountRunAndMakeAscending(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.GallopLeft(System.SByte,System.SByte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.GallopRight(System.SByte,System.SByte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.Int16ArrayTimSort">
            <summary>TimSort implementation for Int16Array.</summary>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.#ctor(System.Int16[])">
            <summary>
            Prevents a default instance of the Int16ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.Sort(System.Int16[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.Sort(System.Int16[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.BinarySort(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.CountRunAndMakeAscending(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.GallopLeft(System.Int16,System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.GallopRight(System.Int16,System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.UInt16ArrayTimSort">
            <summary>TimSort implementation for UInt16Array.</summary>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.#ctor(System.UInt16[])">
            <summary>
            Prevents a default instance of the UInt16ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.Sort(System.UInt16[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.Sort(System.UInt16[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.BinarySort(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.CountRunAndMakeAscending(System.UInt16[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.GallopLeft(System.UInt16,System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.GallopRight(System.UInt16,System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.Int32ArrayTimSort">
            <summary>TimSort implementation for Int32Array.</summary>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.#ctor(System.Int32[])">
            <summary>
            Prevents a default instance of the Int32ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.Sort(System.Int32[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.Sort(System.Int32[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.BinarySort(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.CountRunAndMakeAscending(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.GallopLeft(System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.GallopRight(System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.UInt32ArrayTimSort">
            <summary>TimSort implementation for UInt32Array.</summary>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.#ctor(System.UInt32[])">
            <summary>
            Prevents a default instance of the UInt32ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.Sort(System.UInt32[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.Sort(System.UInt32[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.BinarySort(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.CountRunAndMakeAscending(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.GallopLeft(System.UInt32,System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.GallopRight(System.UInt32,System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.Int64ArrayTimSort">
            <summary>TimSort implementation for Int64Array.</summary>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.#ctor(System.Int64[])">
            <summary>
            Prevents a default instance of the Int64ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.Sort(System.Int64[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.Sort(System.Int64[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.BinarySort(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.CountRunAndMakeAscending(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.GallopLeft(System.Int64,System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.GallopRight(System.Int64,System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.UInt64ArrayTimSort">
            <summary>TimSort implementation for UInt64Array.</summary>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.#ctor(System.UInt64[])">
            <summary>
            Prevents a default instance of the UInt64ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.Sort(System.UInt64[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.Sort(System.UInt64[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.BinarySort(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.CountRunAndMakeAscending(System.UInt64[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.GallopLeft(System.UInt64,System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.GallopRight(System.UInt64,System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.SingleArrayTimSort">
            <summary>TimSort implementation for SingleArray.</summary>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.#ctor(System.Single[])">
            <summary>
            Prevents a default instance of the SingleArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.Sort(System.Single[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.Sort(System.Single[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.BinarySort(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.CountRunAndMakeAscending(System.Single[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.GallopLeft(System.Single,System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.GallopRight(System.Single,System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.DoubleArrayTimSort">
            <summary>TimSort implementation for DoubleArray.</summary>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.#ctor(System.Double[])">
            <summary>
            Prevents a default instance of the DoubleArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.Sort(System.Double[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.Sort(System.Double[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.BinarySort(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.CountRunAndMakeAscending(System.Double[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.GallopLeft(System.Double,System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.GallopRight(System.Double,System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.DecimalArrayTimSort">
            <summary>TimSort implementation for DecimalArray.</summary>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.#ctor(System.Decimal[])">
            <summary>
            Prevents a default instance of the DecimalArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.Sort(System.Decimal[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.Sort(System.Decimal[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.BinarySort(System.Decimal[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.CountRunAndMakeAscending(System.Decimal[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.GallopLeft(System.Decimal,System.Decimal[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.GallopRight(System.Decimal,System.Decimal[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.CharArrayTimSort">
            <summary>TimSort implementation for CharArray.</summary>
        </member>
        <member name="M:TimSort.CharArrayTimSort.#ctor(System.Char[])">
            <summary>
            Prevents a default instance of the CharArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.Sort(System.Char[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.Sort(System.Char[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.BinarySort(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.CountRunAndMakeAscending(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.CharArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.GallopLeft(System.Char,System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.CharArrayTimSort.GallopRight(System.Char,System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.CharArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.DateTimeArrayTimSort">
            <summary>TimSort implementation for DateTimeArray.</summary>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.#ctor(System.DateTime[])">
            <summary>
            Prevents a default instance of the DateTimeArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.Sort(System.DateTime[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.Sort(System.DateTime[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.BinarySort(System.DateTime[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.CountRunAndMakeAscending(System.DateTime[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.GallopLeft(System.DateTime,System.DateTime[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.GallopRight(System.DateTime,System.DateTime[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.TimeSpanArrayTimSort">
            <summary>TimSort implementation for TimeSpanArray.</summary>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.#ctor(System.TimeSpan[])">
            <summary>
            Prevents a default instance of the TimeSpanArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.Sort(System.TimeSpan[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.Sort(System.TimeSpan[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.BinarySort(System.TimeSpan[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.CountRunAndMakeAscending(System.TimeSpan[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.GallopLeft(System.TimeSpan,System.TimeSpan[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.GallopRight(System.TimeSpan,System.TimeSpan[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.GuidArrayTimSort">
            <summary>TimSort implementation for GuidArray.</summary>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.#ctor(System.Guid[])">
            <summary>
            Prevents a default instance of the GuidArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.Sort(System.Guid[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.Sort(System.Guid[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.BinarySort(System.Guid[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.CountRunAndMakeAscending(System.Guid[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.GallopLeft(System.Guid,System.Guid[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.GallopRight(System.Guid,System.Guid[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.AnyArrayTimSort`1">
            <summary>TimSort implementation for AnyArray.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="F:TimSort.AnyArrayTimSort`1._comparer">
            <summary>The comparator for this sort.</summary>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.#ctor(`0[],System.Comparison{`0})">
            <summary>
            Prevents a default instance of the AnyArrayTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.Sort(`0[],System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="comparer">Comparer.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.Sort(`0[],System.Int32,System.Int32,System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.BinarySort(`0[],System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
            <param name="comparer">The comparator to used for the sort.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.CountRunAndMakeAscending(`0[],System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <param name="comparer">the comparator to used for the sort.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.GallopLeft(`0,`0[],System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.GallopRight(`0,`0[],System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.AnyListTimSort`1">
            <summary>TimSort implementation for AnyList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="F:TimSort.AnyListTimSort`1._comparer">
            <summary>The comparator for this sort.</summary>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.#ctor(System.Collections.Generic.List{`0},System.Comparison{`0})">
            <summary>
            Prevents a default instance of the AnyListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.Sort(System.Collections.Generic.List{`0},System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="comparer">Comparer.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.Sort(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.BinarySort(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
            <param name="comparer">The comparator to used for the sort.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <param name="comparer">the comparator to used for the sort.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedReverseRange(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.GallopLeft(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.GallopRight(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.AnyIListTimSort`1">
            <summary>TimSort implementation for AnyIList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="F:TimSort.AnyIListTimSort`1._comparer">
            <summary>The comparator for this sort.</summary>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.#ctor(System.Collections.Generic.IList{`0},System.Comparison{`0})">
            <summary>
            Prevents a default instance of the AnyIListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.Sort(System.Collections.Generic.IList{`0},System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="comparer">Comparer.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.Sort(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.BinarySort(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
            <param name="comparer">The comparator to used for the sort.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <param name="comparer">the comparator to used for the sort.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedReverseRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.GallopLeft(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.GallopRight(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.ComparableArrayTimSort`1">
            <summary>TimSort implementation for ComparableArray.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.#ctor(`0[])">
            <summary>
            Prevents a default instance of the ComparableArrayTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.Sort(`0[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.Sort(`0[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.BinarySort(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.CountRunAndMakeAscending(`0[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.GallopLeft(`0,`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.GallopRight(`0,`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.ComparableListTimSort`1">
            <summary>TimSort implementation for ComparableList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Prevents a default instance of the ComparableListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.Sort(System.Collections.Generic.List{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.Sort(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.BinarySort(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedReverseRange(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.GallopLeft(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.GallopRight(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.ComparableIListTimSort`1">
            <summary>TimSort implementation for ComparableIList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Prevents a default instance of the ComparableIListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.Sort(System.Collections.Generic.IList{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.Sort(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.BinarySort(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedReverseRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.GallopLeft(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.GallopRight(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.TimSortBase`2">
            <summary>
            TimSortBase is base class for all TimSort specific classes. It contains common methods.
            Should not be used directly.
            </summary>
            <typeparam name="TList">The type of the list.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:TimSort.TimSortBase`2.#ctor(`0,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:TimSort.TimSortBase`2"/> class.</summary>
            <param name="array">The array.</param>
            <param name="arrayLength">Length of the array.</param>
        </member>
        <member name="F:TimSort.TimSortBase`2.MIN_MERGE">
            <summary>
            This is the minimum sized sequence that will be merged.  Shorter
            sequences will be lengthened by calling BinarySort.  If the entire
            array is less than this length, no merges will be performed.
            This constant should be a power of two.  It was 64 in Tim Peter's C
            implementation, but 32 was empirically determined to work better in
            this implementation.  In the unlikely event that you set this constant
            to be a number that's not a power of two, you'll need to change the
            <c>minRunLength</c> computation.
            If you decrease this constant, you must change the stackLen
            computation in the TimSort constructor, or you risk an
            ArrayOutOfBounds exception.  See listsort.txt for a discussion
            of the minimum stack length required as a function of the length
            of the array being sorted and the minimum merge sequence length.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2.MIN_GALLOP">
            <summary>
            When we get into galloping mode, we stay there until both runs win less
            often than MIN_GALLOP consecutive times.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2.INITIAL_TMP_STORAGE_LENGTH">
            <summary>
            Maximum initial size of tmp array, which is used for merging. 
            The array can grow to accommodate demand.
            Unlike Tim's original C version, we do not allocate this much storage
            when sorting smaller arrays. This change was required for performance.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._array">
            <summary>The array being sorted.</summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._arrayLength">
            <summary>Cached length of array, it won't change.</summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._minGallop">
            <summary>
            This controls when we get *into* galloping mode.  It is initialized
            to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
            random data, and lower for highly structured data.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._mergeBuffer">
            <summary>
            Temp storage for merges.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._stackSize">
            <summary>
            A stack of pending runs yet to be merged.  Run i starts at
            address base[i] and extends for len[i] elements.  It's always
            true (so long as the indices are in bounds) that:
            <c>runBase[i] + runLen[i] == runBase[i + 1]</c>
            so we could cut the storage for this, but it's a minor amount,
            and keeping all the info explicit simplifies the code.
            </summary>
        </member>
        <member name="M:TimSort.TimSortBase`2.GetMinimumRunLength(System.Int32)">
            <summary>
            Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this 
            will be extended with BinarySort.
            Roughly speaking, the computation is:
            If <c>n &lt; MIN_MERGE</c>, return n (it's too small to bother with fancy stuff).
            Else if n is an exact power of 2, return <c>MIN_MERGE/2</c>.
            Else return an int k, <c>MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE</c>, such that <c>n/k</c> is close to, but strictly 
            less than, an exact power of 2. For the rationale, see listsort.txt.
            </summary>
            <param name="n">the length of the array to be sorted.</param>
            <returns>the length of the minimum run to be merged.</returns>
        </member>
        <member name="M:TimSort.TimSortBase`2.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1. 
            Run i must be the penultimate or antepenultimate run on the stack. 
            In other words, i must be equal to stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.MergeCollapse">
            <summary>
            Examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are
            reestablished: 
            <c><![CDATA[1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1] ]]></c> and 
            <c><![CDATA[2. runLen[i - 2] > runLen[i - 1] ]]></c>
            This method is called each time a new run is pushed onto the stack,
            so the invariants are guaranteed to hold for i &lt; stackSize upon
            entry to the method.
            </summary>
        </member>
        <member name="M:TimSort.TimSortBase`2.MergeForceCollapse">
            <summary>
            Merges all runs on the stack until only one remains.  This method is called once, to complete the sort.
            </summary>
        </member>
        <member name="M:TimSort.TimSortBase`2.PushRun(System.Int32,System.Int32)">
            <summary>
            Pushes the specified run onto the pending-run stack.
            </summary>
            <param name="runBase">index of the first element in the run.</param>
            <param name="runLength">the number of elements in the run.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the external array tmp has at least the specified
            number of elements, increasing its size if necessary.  The size
            increases exponentially to ensure amortized linear time complexity.
            </summary>
            <param name="minCapacity">the minimum required capacity of the tmp array.</param>
            <returns>tmp, whether or not it grew</returns>
        </member>
        <member name="M:TimSort.TimSortBase`2.CheckRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks that fromIndex and toIndex are in range, and throws an
            appropriate exception if they aren't.
            </summary>
            <param name="arrayLen">the length of the array.</param>
            <param name="fromIndex">the index of the first element of the range.</param>
            <param name="toIndex">the index after the last element of the range.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.ArrayReverseRange(`1[],System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.ArrayCopyRange(`1[],System.Int32,System.Int32,System.Int32)">
            <summary>Copies specified array range.</summary>
            <param name="buffer">The buffer.</param>
            <param name="sourceIndex">Index of the source.</param>
            <param name="targetIndex">Index of the target.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.ArrayCopyRange(`1[],System.Int32,`1[],System.Int32,System.Int32)">
            <summary>Copies specified array range.</summary>
            <param name="source">The source.</param>
            <param name="sourceIndex">Index of the source.</param>
            <param name="target">The target.</param>
            <param name="targetIndex">Index of the target.</param>
            <param name="length">The length.</param>
        </member>
    </members>
</doc>
